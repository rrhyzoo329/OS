# Part03 메모리 관리 [02.페이징기법] 

<br>

### 페이징 기법 

<h3>1.  페이징 기법의 구현 </h3>
   
   - 페이징 기법은 고정 분할 방식을 이용한 가상 메모리 관리 기법으로 물리 주소 공간을 같은 크기로 나누어 사용
   - 사진
      - 왼쪽의 가상 주소는 프로세스 입장에서 바라본 메모리 공간으로 항상 0부터 시작 
      - 페이지 : 가상 주소의 분할된 각 영역을 말함 , 첫 번째 페이지 0 
      - 프레임 : 물리 메모리의 각 영역이 가상 주소의 페이지와 구분하기 위해 부르는 이름 
       - 페이지와 프레임의 크기가 같기때문에 페이지는 어떤 프레임에도 배치 될 수 있음
      - 페이지 테이블 : 하나의 열로 구성 되며 모든 페이지의 정보를 순서대로 가지고 있기 때문에 위에서부터 차례대로 페이지0, 페이지1 와 같은 프레임 번호를 가지고 있어 추가 열이 필요 없음
      - 페이지 테이블에 invalid : 물리 메모리에 있지 않고 해당페이지가 스왑 영역에 있다는 의미


<h3>2.  페이징 기법의 주소 변환</h3>
   <b>2.1 주소 변환 과정</b>
      
   - 사진

   - 내용을 읽기 위한 주소 변환 과정
      1. 가장 주소 30번지가 어느 페이지에 있는 지 확인 >> 페이지 3의 0번째 위치
      2. 페이지 테이블의 페이지3으로 가서 해당 페이지가 프레임 1에 있다는 것 확인
      3. 최종적으로 물리메모리 프레임1의 0번째 위치에 접근한 함 >> 이 주소가  가상 주소 30번지의 물리 주소
   - 어떤 값을 저장하기 위한 주소 변환 과정
      1. 가상 주소 18번지가 어느 페이지에 있는 지 확인 >> 페이지 1의 8번째 위치
      2. 페이지 테이블의 페이지1로 가서 해당 페이지가 프레임3에 있다는 것 확인
      3. 프로세스가 저장하려는 값을 프레임 3의 8번 위치에 저장

     <b>2.2 정형화된 주소 변환</b> 
      
      - 페이징 기법에서는 가상 주소를 VA=<P,D>로 표현하며 가상주소 = <페이지, 거리>
         - VA(virtual address): 가상 주소, P: 페이지, PA: 물리 주소, F: 프레임, D: 페이지의 처음 위치부터 해당 주소까지의 거리(distance), 오프셋(offset: 변위)
         - ex) 가상 주소 30번지: VA = <3, 0>, 가상주소 567번지 : VA = <56,7>
      - 페이징 기법의 주소 변환 
         - VA=<P,D> >> PA<F,D>
         - 사진
            - 변환될 때 페이지 테이블을 사용하여 P는 F로 바꾸고 D는 변경 없이 그대로 사용
            - D를 변경하지 않는 이유는 페이지와 프레임의 크기를 똑같이 나누었기 때문임
            - 페이지 테이블은 페이지 번호, 프레임 번호로 구성되며, 각각의 한 줄은 페이지 테이블 엔트리하고 부르며 페이지 테이블 엔트리는 프레임 번호만 가지는데, 테이블에 페이지 번호가 0부터 순서대로 정리되어 있기 때문임 >> 이를 이용하면 간단하게 주소변환 가능

      <b>2.3 1bit CPU의 주소 변환 예</b>
         
         - 한 페이지를 10으로 나누면 가상 주소 30번 >> VA =<3,0>으로 쉽지만 컴퓨터는 2진법을 사용하므로 한 페이지의 크기는 2의 지수승으로 분할됨
         - 가상 주소를 <P,D>로 변환하는 공식
            - P = 나눗셈(가상주소/한 페이지의 크기)의 몫 
            - D = 나눗셈(가상주소/한 페이지의 크기)의 나머지

<h3>3.  페이지 테이블 관리</h3>

   - 페이지 테이블은 메모리 관리자가 자주 사용하는 자료 구조이므로 필요시 빠른 접근을 위해 물리 메모리 영역 중 운영체제 영역의 일부분에 모아 놓음 >> 페이지 테이블의 크기가 크면 프로세스가 실제로 사용할 수 있는 메모리 역역이 줄어듬
   - 메모리 관리자는 페이지 테이블의 위치를 빠르게 파악하기 위해 레지스터를 사용 
   - 페이지 기준 레지스터 : 각 프로세스의 프로세스 제어 블ㄹ록에 저장되는 데이터로, 물리 메모리 내에 페이지 테이블의 시작주소를 가지고 있음  
/

<h3>4.  페이지 테이블 매핑 방식</h3>  

   - 페이지 맵핑 방식

      - 사진
      
      - 직접매핑 : 페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식, 부가 작업 없이 주소 변환
      - 연관매핑 : 페이지 테이블 전체를 스왑 영역에서 관리하는 방식, 물리 메모리의 여유 공간이 작을 때 사용하는 방식으로, 모든 페이지 테이블을 저장장치의 스와 영역에 저장하고 그 중 일부만 물리 메모리에 가지고 있음
         - 페이지 테이블의 일부만 무작위로 가져옴 >> 페이지 번호와 프레임 번호 둘 다 표시 
      - 직합-연관매핑 : 데이터가 무작위로 올라오는 연관 매핑의 문제를 개선한 방법으로 페이지 테이블을 일정한 집합으로 자르고, 자른 덩어리 단위로 물리 메모리에 가져옴
      - 역매핑 : 앞의 세 가지 매핑과 반대로 페이지 테이블을 구성하며 페이지 번호를 기준으로 테이블을 구성하는 대신 물리 메모리의 프레임 번호를 기준으로 테이블을 구성함 
         - 프로세스의 수와 상관없이 테이블이 하나만 존재 >> 그외 매핑은 프로세스마다 페이지 테이블을 만들지만 물리메모리를 기준으로 프레임 테이블을 만들기 때문에 테이블 크기가 작음 
         - 가상 메모리에 접근시 프로세스 아이디와 페이지 번호를 모두 찾아야 함 >> 속도가 느림
   
   <b>4.1 직접 매핑</b>

      - 모든 페이지 테이블을 물리 메모리에 가지고 있는 가장 단순한 방식
      - 물리 메모리가 충분할 때 사용할 수 있으며, 모든 페이지를 물리 메모리에 가지고 있기 때문에 주소 변환 속도가 빠름 
      - 사진 
         - 페이지 테이블 전체가 물리 메모리에 저장 
         - 가상 주소 VA=< P,D >를 물리 주소 PA=< F,D >로 변환하려면 페이지 테이블에 P번째 위치(PTE P)에서 원하는 프레임 값을 얻을 수 있음
         - 페이지 테이블의 시작 주소는 페이지 테이블 기준 레지스터가 가지고 있으므로 물리 메모상 페이지 테이블의 P번째 주소가 시작 주소로부터 P번째 위치에 존재 
         
   <b>4.2 연관 매핑 </b>
      
      - 물리메모리의 여유 공간 이 작을 때 사용
      - 스왑 영역-> 모든 페이지 테이블 저장
      - 물리 메모리-> 일부만 (페이지, 프레임 번호 둘다 표시)
      - 주소 변환 시, 물리 메모리의 페이지 테이블 다 검색 없으면 스왑 영역 페이지 테이블 검색 (시간낭비 심함)
      - 변환 색인 버퍼(TLB): 페이지 번화와 프레임 번호로 구성된 작은 크기의 테이블
         - TLB 히트 : 원하는 페이지 번호가 변환 색인 버퍼에 있는 경우
         - TLB 미스 : 원하는 페이비 번호가 변환 색인 버퍼에 없는 경우
      - 장점 : 전체 페이지 테이블을 물리 메모리에 보관 하지 않음 >> 메모리 절약
      - 단점 :테이블의 일부를 무작위로 갖고 있음 -> 모든 TLB를 검색한 수에야 원하는 페이지가 메모리에 없음을 알 수 있음

   <b>4.3 집합 - 연관 매핑 </b>

   - 연관 매핑 문제점: 메모리에 없으면 모든 테이블을 검색해야함
   - 페이지 테이블을 같은 크기의 여러 묶음으로 나누고, 각 묶음의 시작 주소를 가진 디렉터리 테이블을 새로 만들어 관리 
   - 가상 주소: VA=<P1, P2, D>
      - P1: 디렉터리 테이블에서의 위치(집합 주소)
      - P2: 묶음 내에서의 위치(페이지 주소)

   - 집합-연관 매핑 방식은 페이지 주소를 세분화 함 
      - EX) 페이지 번호 3 >> 0,3 , 페이지 번호 12 >> 1,2, 페이지 번호 178>> 17,8

   - 사진
      - 프로세스가 특정 주소를 요구하면, VA= <P1,P2,D>로 변환
         P1를 이용하여 디렉터리 테이블에서 주소를 찾음
         I(Invalid) : TLB 미스 발생
         시작 주소 : 테이블이 물리 메모리에 존재 

    <b>4.4 역매핑 </b>

      - 물리 메모리의 프레임 번호를 기준으로 테이블 작성 >> 물리 메모리가 어떤 프로세스의 어떤 페이지를 가지고 있는지를 테이블 형태로 구성
      - 프로세스 수 상관 없이 테이블 1개 >> 테이블 크기 작음 >> 메모리 조금 사용
      - 단점: 가상 메모리 접근 시, PID + 페이지 번호 둘 다 찾아야함
      - 테이블: <F, PID, P>
      - 현재 테이블에 원하는 데이터가 없으면 스왑 영역에서 가져옴
      - 페이지 테이블 전체 검사 후 저장장치 접근 >> 검색 시간 낭비



``` 