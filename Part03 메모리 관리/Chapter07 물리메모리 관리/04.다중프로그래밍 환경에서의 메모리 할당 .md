### 다중프로그래밍 환경에서의 메모리 할당
<h3>1.  메모리 분할 방식</h3>

   - 가변 분할 방식 : 프로세스의 크기에 따라 메모리를 나눈 것
   - 고정 분할 방식 : 프로세스의 크기와 상관없이 메모리를 같은 크기로 나눈 것 

   <b>1.1 메모리 분할 방식의 구현</b>

   ![메모리분할](https://user-images.githubusercontent.com/93310395/190116883-d342f1ea-716b-417a-830b-0c61c7f4a745.png)
  
      - 가변 분할 방식: 프로세스의 크기에 맞게 메모리가 분할되므로 메모리의 영역이 각각 다르며 한 프로세스가 연속된 공간에 배치되기 때문에 연속 메모리 할당(contiguous memory allocation)이라고 함
         - 장점 : 프로세스를 한 덩어리로 처리하여 하나의 프로세스를 연속된 공간에 배치함
         - 단점 : 빈 공간을 하나로 합치기 위한 부가적인 작업이 필요하기 때문에 메모리 관리가 복잡함

      - 고정 분할 방식 : 프로세스 크기와 상관없이 같은 크기로 메모리가 분할되며, 큰 프로세스가 메모리에 올라오면 여러 조각으로 나뉘어 배치됨
      - 한 프로세스가 분산되어 배치되기 때문에 비연속 메모리 할당(noncontigous memory allocation)이라고 함
         - 장점 : 메모리를 일정한 크기로 나누어 관리하기 때문에 관리가 수월
         - 단점 : 일정하게 나누어진 공간보다 작은 프로세스가 올라올 경우 메모리 낭비가 발생  


<h3>2.  가변 분할 방식의 메모리 관리</h3>

   <b>2.1 프로세스 배치와 외부 단편화</b>

   ![가변 분ㄹ ㅏ ㄹ](https://user-images.githubusercontent.com/93310395/190117400-95a95933-4770-4239-9b60-5455b6842511.png) 

   - 그림과 같이 물리 메모리 A,B,C,D,E를 순서대로 배치했을 때 프로세스 B와 D가 종료되면 18KB와 17KB의 빈 공간이 생기고 이 때 18KB보다 큰 프로세스가 들어오면 적당한 공간이 없어 메모리를 배정하지 못하는데, 가변 분할 방식에서 발생하는 이러한 작은 빈 공간을 외부 단편화라고 함 

   - 외부단편화 문제를 해결하기 위해 메모리 배치 방식(memory placement strategy)이나 조각 모음(defragementaion)을 사용함
      - 메모리 배치 방식은 작은 조각이 발생하지 않도록 프로세스를 배치하는 작업으로 선처리에 해당하고 조각 모음은 조각이 발생했을 때 작은 조각들을 모아서 하나의 큰 덩어리로 만드는 작업으로 후처리에 해당함

   <b>2.2 메모리 배치 방식</b>

   - 최초배치 : 단편화를 고려하지 않는 것으로 프로세스를 메모리의 빈 공간에 배치할 때 메모리에서 적재 가능한 공간을 순서대로 찾다가 첫번째로 발견한 공간에 프로세스를 배치하는 방법
   - 최적배치: 메모리의 빈 공간을 모두 확인한 후 적당한 크기 가운데 가장 작은 공간에 프로세스를 배치하는 방법
         - 딱 맞는 공간을 찾을 경우 단편화 발생하지 않을 수 있음
         - 딱 맞는 공간이 없을 때는 작은 조각을 만들 수밖에 없음
   - 최악배치: 메모리의 빈 공간을 모두 확인한 후 가장 큰 공간에 프로세스를 배치하는 방법, 최적과 반대
         - 프로세스를 배치하고 남는 공간이 크기 때문에 쓸모가 있음
         - 빈 공간의 크기가 클 때는 효과적이지만 점점 줄어들수록 작은 조각을 만들 수 밖에 없음

   <b>2.3 조각 모음</b>

   - 조각 모음 : 메모리보다 작은 프로세스가 작업을 마치고 난 후 생성된 작은 조각을 하나의 큰 덩어리로 만드는 것 
   - 조각 모음 순서
            1. 조각 모음을 하기 위해 이동할 프로세스의 동작을 멈춤
            2. 프로세스를 적당한 위치로 이동시킨 후 프로세스 상대 주소값을 변경함
            3. 일련의 작업을 마친 후 프로세스 재시작
   - 조각 모음을 하기 위해서는 프로세스를 중지시키고, 이동하고, 주소를 바꾸고, 다시 시작하는 작업을 해야 하기 때문에 많은 시간이 걸림
  
<h3>3.  고정 분할 방식의 메모리 관리</h3>

   <b>3.1 프로세스 배치와 내부 단편화</b>

   ![고정분할](https://user-images.githubusercontent.com/93310395/190120570-91462ea3-d9a2-4262-8212-3504362dbf8d.png)

   - 분할된 크기가 20KB이므로 40KB인 프로세스 A는 A1과 A2로 나뉘어 메모리에 할당되며 30KB인 프로세스 C는 C1과 C2로 나뉘는데 메모리에 남는 공간이 없으므로 프로세스 C2는 스왑 영역으로 옮겨짐

   <b>3.2 내부단편화</b>

   - 내부단편화 : 일정한 크기로 나뉜 파티션 안쪽으로 작은 조각이 발생하고 각 메모리 조각에 프로세스를 배치하고 공간이 남은 현상
   - 가변 분할 방식의 외부 단편화와 달리 조각모음을 할 수 없고 남는 공간을 다른 프로세스에 배정할 수도 없기 때문에 동일하게 분할되는 공간의 크기를 조절하여 내부 단편화를 최소화 시켜야 함

   ![비교](https://user-images.githubusercontent.com/93310395/190121051-74d3afda-079f-4103-a71c-8e360baa35f4.png)


<h3>4.  버디 시스템</h3>

   <b>4.1 버디 시스템의 작동 방식</b>

   - 버디 시스템의 특징 : 가변 분할 방식과 고정 분할 방식의 중간 구조
   - 버디 시스템 작동 방식
      1. 프로세스의 크기에 맞게 메모리를 1/2로 자르고 프로세스를 메모리에 배치
      2. 나뉜 메모리의 각 구역에는 프로세스가 1개만 들어감
      3. 프로세스가 종료되면 주변의 빈 조각과 합쳐져서 하나의 덩어리로 만듬
   - 버디 시스템이 가변 분할 방식보다 효과적으로 공간을 관리할 수 있는 이유는 비슷한 크기의 덩어리가 서로 모여 있어 통합하기 쉬움
    
   <b>4.2 버디 시스템 특징</b>

   - 가변 분할 방식처럼 메모리가 프로세스 크기대로 나뉨
   - 고정 분할 방식처럼 하나의 구역에 다른 프로세스가 들어갈 수 없고, 내부 단편화 발생
   - 비슷한 크기의 조각이 서로 모이는 효과가 있음
         - 작은 조각을 통합해 큰 조각을 만들기 용이함




​
   

      

   



``` 