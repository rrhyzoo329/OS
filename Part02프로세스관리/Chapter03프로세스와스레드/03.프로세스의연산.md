# Chapter03프로세스와스레드 [03.프로세스의연산] 

<br>

### 프로세스의 연산

1. 프로세스의 구조 

   ![그림4](https://user-images.githubusercontent.com/93310395/177509809-d6362ba9-714e-4a70-9c85-62e526a3f091.png)

- 코드 영역 
  프로그램의 본문이 기술된 곳으로 텍스트 영역이라고도 함,프로그래머가 작성한 프로그램이 코드 영역에 탑재되며 읽기 전용으로 처리된다.
- 데이터 영역
   코드가 실행되면서 여러가지 변수나 파일 등의 각종 데이터들을 모아놓는 곳이다. 데이터는 변하는 값이기 때문에 읽기와 쓰기가 가능하다.
- 스택 영역 
   운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터들을 모아놓는 곳이다.스택 영역은 운영체제가 사용자의 프로세스를 작동하기 위해 유지하는 영역이므로 사용자에게 보이지 않는다.

2. 프로세스의 생성과 복사
-  사용자가 프로그램을 실행하면 운영체제는 프로그램을 메모리로 가져와 코드 영역에 넣고 프로세스 제어 블록을 생성한다.그리고 메모리에 데이터 영역과 스택 영역을 확보한 후 프로세스를 실행한다.
   - fork() 시스템 호출의 개념 
      - fork() 시스템 호출은 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수
      - 커널에서 제공하는 이 함수는 프로세스를 복사하는 일종의 시스템 호출
      - 실행하던 프로세스는 부모 프로세스, 새로 생긴 프로세스는 자식 프로세스로서 부모 - 자식 관계 생성 
      - 예) 크롭 ctrl + N 키를 누르면 같은 페이지 생성 => 새로운 크롬을 실행한 것이 아니라 현재 크롭 프로세스 복사 

   - fork( ) 시스템 호출의 동작 과정  

      ![그림5](https://user-images.githubusercontent.com/93310395/177511609-490ba950-ba93-4d4d-98ba-1acf40d27ac2.png)

   - 프로세스 구분자의 변경 : PID는 고유한 번호로서 부모와 자식 관계라도 다르다.
   - 메모리 관련 정보 : 부모 프로세스와 자식 프로세스가 차지하고 있는 메모리 위치가 다르다.

   - fork( ) 시스템 호출의 장점
      - 프로세스의 생성 속도가 빠르다 : 하드디스크로부터 프로그램을 새로 가져오지 않고 기존 메모리에서 복사하기 때문에 생성속도가 빠름
      - 추가 작업 없이 자원을 상속할 수 있다 : 부모 프로세스가 사용하던 모든 자원을 추가 작업 없이 상속 가능
      - 시스템 관리를 효율적으로 할 수 있다 : 프로세스를 종료하면 프로세스가 사용하던 메모리 영역, 파일, 하드웨어를 정리해야 하는데, 이러한 정리를 부모 프로세스에게 맡김으로써 효율적인 관리가 가능

3. 프로세스의 전환 
- exec( ) 시스템 호출의 개념
   - exec( ) 시스템 호출은 기존의 프로세스를 새로운 프로세스로 전환하는 함수
   - exec( ) 시스템 호출을 사용하는 목적은 프로세스의 구조체를 재활용하기 위함 
      - 프로세스 만들기 위해서는 프로세스 제어 블록 만들고 메모리 자리 확보하는 과정이 필요하지만 exec( ) 시스템 호출 사용하면 이미 만들어진 프로세스 제어 블록, 메모리 영역, 부모 - 자식 관계 그대로 사용할 수 있음
   - 새로운 코드 영역만 가져오기 때문에 운영체제 작업이 수월하다.

- exec( ) 시스템 호출의 동작 과정 
   
   ![그림6](https://user-images.githubusercontent.com/93310395/177513582-de3ee570-cf70-44d7-873e-8e5d337c3caf.png)   


*fORK()와 EXEC()
 - FORK() : 새로운 프로세스를 복사함
 - EXEC() : 프로세스는 그대로 둔 채 내용만 바꾸는 시스템 호툴, 현재의 프로세스가 완전히 다른 프로세스로 전환    

4. 프로세스의 계층 구조
- 유닉스의 프로세스 계층 구조
   - 유닉스에서 커널이 처음 메모리에 올라와 부팅되면 커널 관련 프로세스를 여러개 만드는데 그 중 init 프로세스는 모든 프로세스의 출발점이 됨
   - 운영체제는 프로세스를 효율적으로 관리하기 위해 init 프로세스를 만든 다음 나머지 프로세스를 init 프로세스의 자식으로 만듬

    ![image](https://user-images.githubusercontent.com/93310395/177536696-5af082c2-321c-44bd-8ea6-a521712ec7f1.png)

- 유닉스의 프로세스 구조의 장점
   - 여러 작업의 동시 처리 

      ![그림7](https://user-images.githubusercontent.com/93310395/177537750-a3fa8fb7-ea4a-4873-ab8e-e0ae0210f1c0.png)

      - login 프로세스는 인증을 거쳐 컴퓨터에 접속하는 과정을 처리
      - 예를 들어 사용자 3명이 동시에 컴퓨터에 접속한다면 동시에 3명을 처리해야 하는데, login 프로세스는 1명만 처리 가능함. 이 때 fork를 활용하여 login 프로세스를 여러 개 만들어 사용자에게 나누어 주면 새로운 사용자가 들어올 때마다 작업을 동시에 처리 가능

*프로세스의 재사용

   ![프로세스의 재사용](https://user-images.githubusercontent.com/93310395/177697696-8dceeee1-998a-437b-b3d8-504cc00b797d.png)

   - login 프로세스 통과하면 shell 프로세스가 필요함 => shell 프로세스가 있어야 사용자가 운영체제에 명령을 내리고 결과를 받을 수 있음 
   - login 프로세스가 완료 => 해당 프로세스 종료 => 새로운 프로세스 생성 => login 프로세스가 차지한 메모리 공간 지움, PCB제거 => 새로운 메모리 공간, 새로운 PCB생성 

   - exec() 시스템 호출을 사용 :
      - 비효율적인 과정을 반복하지 않아도 됨
      - login 프로세스의 구조를 shell 프로세스로 다시 활용
      - 기존의 부모- 자식 관계도 유지 가능 
      - login 프로세스를 shell프로세스로 바꾼 후 사용자 명령 대기  
   - 자원 회수(garbage collection)가 용이
      - 프로세스를 계층 구조로 만들면 프로세스 간의 책임 관계가 분명해져서 시스템을 관리하기 수월하며, 프로세스가 작업을 마치면 사용하던 자원을 부모 프로세스가 회수하면 됨

- 미아 프로세스(고아 프로세스 : orphan process, 좀비 프로세스 : Zombie process)
   - 부모 프로세스는 자원을 회수하기 위해 자식 프로세스가 끝날 때 까지 기다려야 함. 그런데 부모 프로세스가 먼저 종료되거나 자식 프로세스가 비 정상적으로 종료되면 종료 후에도 사용하던 자원이 그대로 남아 있는데 이러한 프로세스를 고아 프로세스라고 함
      - 고아 프로세스(orphan process) : 부모 프로세스가 자식보다 먼저 죽는 경우 발생
      - 좀비 프로세스(zombie process) : 자식 프로세스가 종료했음에도 부모가 뒤처리를 하지 않을 때 발생
   - 미아 프로세스가 많아지면 자원이 낭비됨 => 운영체제는 반환되지 못한 자원을 회수하는 자원회수를 주기적으로 해야함
   - ex) c 언어 main() 사용 후 exit(), return()를 적어줌 
   - 자바같은 경우 모든 클래스는 object의 자식이 되어 하위 프로세스에 상속되어 자원의 사용이 용이하고, 사용 후 자원이 쉽게 회수 됨 

      
      















   

 
``` 