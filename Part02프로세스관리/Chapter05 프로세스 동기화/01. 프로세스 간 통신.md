# Chapter05 프로세스 동기화 [1.프로세스간통신] 

<br>

### 프로세스 간 통신
<h3>1.  프로세스 간 통신의 개념</h3>

   - 프로세스간 통신이란? 
      - 프로세스는 시스템 내에서 독립적으로 실행되기도 하고 데이터를 주고받으며 협업하기도 함 
      - IPC(inter process communication) : 프로세스가 다른 프로세스와 데이터를 주고받는 프로세스 간 통신, 같은 컴퓨터 내 뿐만 아니라 네트워크로 연결된 다른 컴퓨터에 있는 프로세스와의 통신도 포함

   - 프로세스 통신의 종류
      ![image](https://user-images.githubusercontent.com/93310395/183721451-3cd5a652-9c7c-4750-bef8-5bc062656247.png)

      - 프로세스 내부 데이터 통신 : 하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우, 전역변수와 파일 이용
      - 프로세스 간 데이터 통신 : 같은 컴퓨터에 있는 여러 프로세스끼리 통신하는 경우, 공용 파일 또는 운영체제가 제공하는 파이프 이용
      - 네트워크를 이용한 데이터 통신 : 여러 컴퓨터가 네트워크로 연결되어 통신하는 경우, 소켓을 이용

      ** 어떤 통신 방식을 이용할지 결정할 때 : 오버헤드 고려해야 한다
         - 예를 들어 같은 컴퓨터에 있는 프로세스끼리도 소켓을 이용하여 통신이 가능함 => IP주소로 127.0.0.1 같은 루프백 사용하여 연결한다. 하지만 소켓을 이용하는 경우 잔처리가 필요하여 속도가 느리기 때문에 같은 컴퓨터내 프로세스 통신에는 사용하지 않음 

<h3>2.  프로세스 간 통신의 분류</h3>
   <b>2.1 통신방향에 따른 분류</b>

   - 함수호출도 데이터를 주고받는다는 의미에서 통신이지만 함수는 하나의 프로세스 내에서 순차적으로 실행되기때문에 통신이라고 부르지 않음
   - 통신 방향에 따른 분류 
      - 양방향 통신(duplex communication) : 데이터를 동시에 양쪽 방향으로 전송가능한 구조(소켓통신)
      - 반양방향 통신(half-duplex communication) : 데이터를 양쪽 방향으로 전송할 수 있으나 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송이 가능한 구조(무전기)
      - 단방향통신(simplex communication) : 모스 신호처럼 한쪽 방향으로만 데이터를 전송할 수있는 구조(전역변수, 파이프)
   
   - 통신 구현 방식에 따른 분류
      - 빠른 대기(Busy waiting) : 전역변수 이용시 수시로 데이터를 점검하여 데이터가 전송되었는 지 확인하며, 시스템 차원에서는 큰 자원 낭비가 될 수 있음 

                  while(true){
                     if(preValue != curValue){
                  // ... 전역 변수의 변화를 캐치
               }
            }

      - 동기화(synchronization) : 데이터가 도착했음을 알려주며 바쁜 대기를 이용하지 않아도 운영체제가 자동으로 실행한다

      - 통신 구현 방식에 따른 분류
         - 대기가 있는 통신(bloking communacation) / 동기화 통신(synchronous communacation): 동기화를 지원하는 통신 방식이며 데이터를 받는 쪽은 데이터가 도착할때까지 대기 상태임(파이프, 소켓)
         - 대기가 없는 통신(non-bloking communacation) / 비동기화 통신(asynchronous communacation) : 동기화를 지원하지 않는 통신 방식이며 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 확인함(전역변수, 파일)

         전역 변수와 파일을 이용한 통신은 대기가 없는 통신의 대표적인 예이다. 전역 변수와 같이 공유 메모리를 이용하여 통신을 하든, 파일을 이용하여 통신을 하든, 보내는 쪽과 받는 쪽이 동기화되지 않는다. 대기가 없는 통신은 통신 오버헤드는 적지만 busy waiting 처럼 사용자가 직접 처리해야 하는 작업이 많다.

         즉, 대기가 있는 통신은 운영체제가 자동으로 동기화를 제공해주는 경우가 많고, 대기가 없는 통신은 자동으로 동기화를 제공해주는 것이 아닌 사용자가 직접 동기화 작업을 해야한다.

<h3>3. 프로세스 간의 통신의 종류</h3>

   - 프로세스 간 통신은 데이터를 주거나 받는 동작으로 이루어지며 이는 쓰기 연산과 읽기 연산을 간소화 할 수 있다.
      - send -> write(GV, message)
      - receive -> read(GV, message)

   GV는 전역 변수로, message에 따라 GV에 값을 써주는 것이 send, message에 따라 GV를 읽는 것이 receive가 된다.
   이러한 프로세스 간 통신 방식은 전역 변수 뿐만 아니라, 파이프, 소켓, 파일을 이용한 통신에도 동일하게 적용된다.
   
   <b>3.1 전역변수를 이용한 통신</b> 

   -  전역 변수를 이용한 통신은 공동으로 관리하는 메모리를 이용하여 데이터를 주고받으며, 직접적으로 관련이 있는 프로세스간 이용한다.
   - 데이터를 보내는 쪽에서는 전역 변수나 파일에 값을 쓰고, 데이터를 받는 쪽에서 전역 변수의 값을 읽는다.
      - 부모와 자식 프로세스 간의 통신에도 사용됩니다.
         
            int GV;

            int main();
            {  int pip;
               pid = fork();
            }

      main() 이전에 정의된 전역 변수 GV는 부모 프로세스와 자식 프로세스가 공유하는 메모리 영역이며, GV에 데이터를 읽고 쓰는 방식으로 통신 

   ![저장](https://user-images.githubusercontent.com/93310395/183724018-211ce515-0da5-4606-9113-910be5084fb9.png)

   - 다음의 그림은 프로세스가 fork하여 만든 자식 프로세스와 전역 변수로 양방향으로 통신하는 모습을 보여준다. 
   - 양방향으로 통신하기 위해 전역변수 R과 L을 정의한 후 fork()를 사용하여 부모프로세스(P), 자식프로세스(C) 생성함.
   - 동기화 문제 : P가 전역변수 R에 쓰기 연산을 한다고 했을 시 프로세스가 데이터를 읽기위해 전역 변수 R이 바뀔 때까지 작동을 하지않고 check만 반복하게되는 busy waiting에 빠지는 단점이 있다.

  <b>3.2 파일을 이용한 통신</b>  

   - 파일은 열고(open) ,쓰기(write), 읽기(read), 닫기(close)로 총 4가지로 이루어져 있다.

         #include <stdio.h>
         #include <unistd.h>
         #include <fcntl.h>

         int main () {
            int fd;
            char buf[5];
            fd = open("com.txt", O_RDWR) // com.txt 읽고 쓰기(O_RDWR)가 가능하도록 준비, 읽기 전용(O_RDONLY)
            write(fd, "Test", 5); // 파일에 Test 문자열을 씀 
            read(fd, buf, 5); // 파일에서 5B를 읽어 변수 buf에 저장
            close(fd); // 파일 닫기 
            exit(0);
         }   
   - fd 변수는, file descriptor ( 파일 기술자 ) 이고, 이 변수를 통해서만 파일 읽기 / 쓰기에 접근 할 수 있음
   - open하여 fd(파일 기술자 : file descriptor)을 받아 이를 통해 파일을 제어한다. fd는 반드시 사용 후에 돌려주어야 하기 때문에 close를 호출해주어야 한다.
   - fd를 사용하여 파일의 정보를 쓰고, fd에 buf를 저장하여 정보를 읽어 올수도 있다

   ![파일](https://user-images.githubusercontent.com/93310395/183725160-77699caf-744b-4dcb-9f6d-6b6a186fd604.png)

   - 입출력은 다음과 같이 입출력 프로세스가 따로 존재하여 관리하며, 운영체제의 입장에서 보면 저장장치의 데이터를 읽고 쓰는 것도 일반 프로세스와 입출력 프로세스 간의 통신이다.

   - 파일을 이용한 통신은 부모-자식 관계 프로세스 간 통신에 많이 사용되며 운영체제가 프로세스 동기화를 제공하진 않는다. 그래서 프로세스가 알아서 동기화를 해야하는데 주로 부모 프로세스가 wait() 함수를 이용하여 자식 프로세스의 작업이 끝날 때까지 기다렸다가 작업을 시작한다.

<b>3.3 파이프를 이용한 통신</b> 

   - 파이프는 운영체제가 제공하는 동기화 통신 방식으로 파일 입출력과 같이 Open() 함수로 descripter를 받고 작업을 한 후에 close()로 마무리 한다. 파이프를 이용한 통신은 전역 통신과 마찬가지로 단방향 통신이다. 때문에 양방향 통신을 하기 위해서는 파이프 두 개를 사용해야 한다.

   ![파이프](https://user-images.githubusercontent.com/93310395/183725315-b4fef9eb-34fc-4501-9f4c-46ef0218b895.png)

   - 파이프는 queue와 같기 때문에 한쪽에서는 write( push )하는 것이고, 한 쪽은 read( pop ) 밖에 할 수가 없다. 만약 프로세스 B가 파이프 1에 대해 읽기 연산을 수행했는데 프로세스 A가 파이프 1에 아직 쓰기 연산을 하지 않았다면 프로세스 B는 대기 상태가 된다. 이러한 대기 상태는 프로세스 A가 파이프 1에 데이터를 쓰는 순간 자동으로 풀려 동기화가 이루어진다. 프로세스 B는 Busy waiting를 하지 않아도 된다.

   - 파이프는 이름 없는 파이프와 이름있는 파이프로 나뉜다.
      - 이름 없는 파이프(anonymous pipe) : 일반적으로 파이프라고 하면 이름없는 파이프를 가리킨다. 부모와 자식 프로세스 혹은 같은 부모를 가진 자식 프로세스와 같이 서로 관련 있는 프로세스 간 통신에 사용된다.
      - 이름 있는 파이프(named pipe) : FIFO라 불리는 특수 파일을 이용하며 서로 관련 없는 프로세스 간 통신에 사용되며, 파일과 같이 취급할 수 있고 프로세스 간 통신(IPC)을 위해 프로세스가 오픈되어 사용한다.


<b>3.4 소켓을 이용한 통신</b> 

   - 여러 컴퓨터에 있는 프로세스 간 통신은 네트워킹이라고 한다. 네트워킹 상황에서의 통신은 원격 프로시저 호출(RPC)이나 소켓을 사용한다. 
   - 프로시저 호출이 한 컴퓨터에 있는 함수를 호출하는 것이라면, 원격 프로시저 호출은 다른 컴퓨터에 있는 함수를 호출하는 것이다. 자바 같은 경우 다른 컴퓨터에 있는 객체의 메서드를 호출하는 것이 원격 프로시저 호출이다.

   ![소켓](https://user-images.githubusercontent.com/93310395/183725409-a89708fd-acf5-4e5e-b35d-f75f06dcbeed.png)

   - 일반적으로 원격 프로시저 호출은 소켓을 이용하여 구현한다. 위의 그림은 소켓을 이용한 통신을 나타낸 것이다. 다른 컴퓨터에 있는 프로세스와 통신하려면 그 컴퓨터의 위치를 파악하고, 원격지의 시스템 내 여러 프로세스 중 어떤 프로세스와 통신을 할지도 결정해야 한다.
   - 이때 통신하고자 하는 프로세스는 소켓에 쓰기 연산을 하면 데이터가 전송되고, 읽기 연산을 하면 데이터를 받게 된다.
   - 소켓은 프로세스 동기화를 지원하므로, 데이터를 받는 쪽의 프로세스가 busy waiting을 하지 않아도 된다. 양방향 통신을 하기위해 파이프는 2개를 사용했지만 소켓은 하나만 사용해도 양방향 통신이 가능하다.
   - 참고로, 네트워크의 기본은 소켓이기 때문에 네트워크 프로그래밍을 소켓 프로그래밍이라고도 한다.

<b>3.5 정리</b> 

   ![정리](https://user-images.githubusercontent.com/93310395/183725734-2c4a6859-2fa0-4c03-9f4d-52d3645709c7.png)



``` 